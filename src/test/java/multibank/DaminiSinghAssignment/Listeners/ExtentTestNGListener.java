package multibank.DaminiSinghAssignment.Listeners;

import com.aventstack.extentreports.ExtentReports;
import com.aventstack.extentreports.ExtentTest;
import com.aventstack.extentreports.Status;
import org.testng.*;

/**
 * ExtentTestNGListener
 * ------------------------------------------------------------------
 * TestNG Listener implementation that integrates ExtentReports with
 * the test lifecycle.
 *
 * Key responsibilities:
 *   • Create ExtentTest entries when tests start.
 *   • Log PASS/FAIL/SKIP statuses in real time.
 *   • Attach screenshots on failure (optional).
 *   • Flush the final HTML report after suite completion.
 *
 * Pattern used: ThreadLocal ensures proper reporting in parallel runs.
 */
public class ExtentTestNGListener implements ITestListener, ISuiteListener {

    /** Shared ExtentReports instance (singleton via ExtentManager) */
    private static ExtentReports extent = ExtentManager.getInstance();

    /**
     * ThreadLocal ExtentTest ensures each running test thread
     * maintains its own dedicated report entry.
     */
    private static ThreadLocal<ExtentTest> testThread = new ThreadLocal<>();

    // ============================================================
    // SUITE LEVEL EVENTS
    // ============================================================

    @Override
    public void onStart(ISuite suite) {
        // Called when the entire suite starts running
        // Can be used to initialize suite-level reporting if needed
    }

    @Override
    public void onFinish(ISuite suite) {
        // Flush writes all logs to the final HTML report
        extent.flush();
    }

    // ============================================================
    // TEST METHOD LEVEL EVENTS
    // ============================================================

    /**
     * Called when a test method begins.
     * Creates a new ExtentTest object and assigns it to the ThreadLocal.
     */
    @Override
    public void onTestStart(ITestResult result) {
        String testName = result.getMethod().getMethodName();

        ExtentTest test = extent.createTest(testName)
                // Assign category based on <test name=""> from TestNG XML
                .assignCategory(result.getTestContext().getCurrentXmlTest().getName());

        testThread.set(test);
    }

    /** Log PASS status */
    @Override
    public void onTestSuccess(ITestResult result) {
        testThread.get().log(Status.PASS, "Test passed");
    }

    /**
     * Log FAIL status + Throwable details.
     * Also attaches screenshot captured by ScreenshotListener (if saved).
     */
    @Override
    public void onTestFailure(ITestResult result) {
        ExtentTest test = testThread.get();

        test.log(Status.FAIL, "Test failed: " + result.getThrowable());

        // ---- Screenshot Handling (if available) ----
        String browser = result.getTestContext().getCurrentXmlTest().getParameter("browser");
        long threadId = Thread.currentThread().getId();
        String testName = result.getMethod().getMethodName();

        /**
         * Screenshot filename format generated by ScreenshotListener:
         *   artifacts/<browser>_T<threadId>_<testName>_FINAL_FAIL.png
         */
        String screenshotPath =
                "artifacts/" + browser + "_T" + threadId + "_" + testName + "_FINAL_FAIL.png";

        test.addScreenCaptureFromPath(screenshotPath);
    }

    /** Log SKIP status */
    @Override
    public void onTestSkipped(ITestResult result) {
        testThread.get().log(Status.SKIP, "Test skipped");
    }

    @Override
    public void onTestFailedButWithinSuccessPercentage(ITestResult result) {
        // Not required for this framework
    }

    @Override
    public void onTestFailedWithTimeout(ITestResult result) {
        // Treat timeout failure same as normal failure
        onTestFailure(result);
    }

    @Override
    public void onStart(ITestContext context) {
        // Not needed here, but available for future extensions
    }

    @Override
    public void onFinish(ITestContext context) {
        // Not used; suite-level onFinish already flushes report
    }
}
